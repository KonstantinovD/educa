
                    ВИДЫ НАСЛЕДОВАНИЯ МОДЕЛЕЙ DJANGO

    Для реализации таких моделей нам пригодится наследование. В Django существует
наследование моделей, которое работает аналогично наследованию
класса и может быть реализовано одним из трех способов:
  1) абстрактные модели полезны, когда вы хотите описать некоторую общую
информацию. Для них не создается таблица в базе данных;
  2) наследование с помощью нескольких таблиц применимо, когда каждая
модель в иерархии рассматривается как обособленная и может быть использована
отдельно от других. В этом случае для каждой модели
создается ее собственная таблица;
  3) прокси-модели полезны, когда вы хотите хранить те же данные для всех
моделей, но реализовать для каждой из них какую-то отдельную функциональность
(например, создать методы, переопределить или добавить
менеджеры, использовать другие опции класса Meta). Для прокси-моделей
таблицы в базе данных не создаются.
    Давайте рассмотрим каждый из этих способов подробнее.


                        АБСТРАКТНЫЕ МОДЕЛИ

    Абстрактная модель – это базовый класс. В нем необходимо определить поля,
которые будут общими для всех дочерних классов. Django не добавляет в базу
данных таблицу для абстрактной модели, но для каждого дочернего класса
включает столбцы, соответствующие полям родительского класса.
    Чтобы указать, что модель является абстрактной, достаточно задать атрибут
abstract=True в опциях класса Meta. Django распознает такую настройку и не
создает таблицу в базе данных. Чтобы создать дочернюю модель, просто унаследуйте
ее от абстрактной.
    Этот пример демонстрирует абстрактную модель, Content, и дочернюю, Text:
-----------------------------------------------------------------------------------
    class BaseContent(models.Model):
        title = models.CharField(max_length=100)
        created = models.DateTimeField(auto_now_add=True)
        class Meta:
            abstract = True

    class Text(BaseContent):
        body = models.TextField()
-----------------------------------------------------------------------------------
    В этом случае в базе данных будет создана только таблица для модели Text со
столбцами title, created и body.


                      НАСЛЕДОВАНИЕ С НЕСКОЛЬКИМИ ТАБЛИЦАМИ

    В случае наследования с несколькими таблицами для каждой модели создается
соответствующая таблица. Django делает ссылку типа OneToOneField
на родительскую модель из дочерней.
    Чтобы применить этот способ, достаточно унаследовать класс дочерней
модели от родительской, как это показано в примере:
-----------------------------------------------------------------------------------
    class BaseContent(models.Model):
        title = models.CharField(max_length=100)
        created = models.DateTimeField(auto_now_add=True)

    class Text(BaseContent):
        body = models.TextField()
-----------------------------------------------------------------------------------
    Django автоматически добавит поле OneToOneField в модель Text и создаст две
таблицы в базе данных.


                                ПРОКСИ-МОДЕЛИ

    Они используются, когда модели хранят одинаковые данные, но поведение
классов отличается (например, у них разные методы или другие опции).
Все они работают с одной таблицей. Чтобы создать прокси-модель, добавьте
в класс Meta атрибут proxy=True.
    Давайте посмотрим, как это выглядит, на конкретном примере:
-----------------------------------------------------------------------------------
    from django.utils import timezone

    class BaseContent(models.Model):
        title = models.CharField(max_length=100)
        created = models.DateTimeField(auto_now_add=True)

    class OrderedContent(BaseContent):
        class Meta:
            proxy = True
            ordering = ['created']

        def created_delta(self):
            return timezone.now() - self.created
-----------------------------------------------------------------------------------
    Здесь мы создали прокси-модель OrderedContent. Она добавляет сортировку
по умолчанию для QuerySetʼов и метод created_delta(). Обе модели работают
с одной и той же таблицей в базе данных, и обратиться к объектам можно через
ORM для каждой модели.